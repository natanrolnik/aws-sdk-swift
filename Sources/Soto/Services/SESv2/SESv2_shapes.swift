//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension SESv2 {
    // MARK: Enums

    public enum BehaviorOnMxFailure: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rejectMessage = "REJECT_MESSAGE"
        case useDefaultValue = "USE_DEFAULT_VALUE"
        public var description: String { return self.rawValue }
    }

    public enum BounceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case permanent = "PERMANENT"
        case transient = "TRANSIENT"
        case undetermined = "UNDETERMINED"
        public var description: String { return self.rawValue }
    }

    public enum BulkEmailStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountDailyQuotaExceeded = "ACCOUNT_DAILY_QUOTA_EXCEEDED"
        case accountSendingPaused = "ACCOUNT_SENDING_PAUSED"
        case accountSuspended = "ACCOUNT_SUSPENDED"
        case accountThrottled = "ACCOUNT_THROTTLED"
        case configurationSetNotFound = "CONFIGURATION_SET_NOT_FOUND"
        case configurationSetSendingPaused = "CONFIGURATION_SET_SENDING_PAUSED"
        case failed = "FAILED"
        case invalidParameter = "INVALID_PARAMETER"
        case invalidSendingPoolName = "INVALID_SENDING_POOL_NAME"
        case mailFromDomainNotVerified = "MAIL_FROM_DOMAIN_NOT_VERIFIED"
        case messageRejected = "MESSAGE_REJECTED"
        case success = "SUCCESS"
        case templateNotFound = "TEMPLATE_NOT_FOUND"
        case transientFailure = "TRANSIENT_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum ContactLanguage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case en = "EN"
        case ja = "JA"
        public var description: String { return self.rawValue }
    }

    public enum DataFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum DeliveryEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complaint = "COMPLAINT"
        case delivery = "DELIVERY"
        case permanentBounce = "PERMANENT_BOUNCE"
        case send = "SEND"
        case transientBounce = "TRANSIENT_BOUNCE"
        case undeterminedBounce = "UNDETERMINED_BOUNCE"
        public var description: String { return self.rawValue }
    }

    public enum DimensionValueSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case emailHeader = "EMAIL_HEADER"
        case linkTag = "LINK_TAG"
        case messageTag = "MESSAGE_TAG"
        public var description: String { return self.rawValue }
    }

    public enum EngagementEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case click = "CLICK"
        case open = "OPEN"
        public var description: String { return self.rawValue }
    }

    public enum EventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bounce = "BOUNCE"
        case click = "CLICK"
        case complaint = "COMPLAINT"
        case delivery = "DELIVERY"
        case deliveryDelay = "DELIVERY_DELAY"
        case open = "OPEN"
        case reject = "REJECT"
        case renderingFailure = "RENDERING_FAILURE"
        case send = "SEND"
        case subscription = "SUBSCRIPTION"
        public var description: String { return self.rawValue }
    }

    public enum FeatureStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum HttpsPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case optional = "OPTIONAL"
        case require = "REQUIRE"
        case requireOpenOnly = "REQUIRE_OPEN_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum IdentityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case domain = "DOMAIN"
        case emailAddress = "EMAIL_ADDRESS"
        case managedDomain = "MANAGED_DOMAIN"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case created = "CREATED"
        case failed = "FAILED"
        case processing = "PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum ListRecommendationsFilterKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case impact = "IMPACT"
        case resourceArn = "RESOURCE_ARN"
        case status = "STATUS"
        case type = "TYPE"
        public var description: String { return self.rawValue }
    }

    public enum MailFromDomainStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case pending = "PENDING"
        case success = "SUCCESS"
        case temporaryFailure = "TEMPORARY_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum MailType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case marketing = "MARKETING"
        case transactional = "TRANSACTIONAL"
        public var description: String { return self.rawValue }
    }

    public enum Metric: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case click = "CLICK"
        case complaint = "COMPLAINT"
        case delivery = "DELIVERY"
        case deliveryClick = "DELIVERY_CLICK"
        case deliveryComplaint = "DELIVERY_COMPLAINT"
        case deliveryOpen = "DELIVERY_OPEN"
        case open = "OPEN"
        case permanentBounce = "PERMANENT_BOUNCE"
        case send = "SEND"
        case transientBounce = "TRANSIENT_BOUNCE"
        public var description: String { return self.rawValue }
    }

    public enum MetricAggregation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rate = "RATE"
        case volume = "VOLUME"
        public var description: String { return self.rawValue }
    }

    public enum MetricDimensionName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configurationSet = "CONFIGURATION_SET"
        case emailIdentity = "EMAIL_IDENTITY"
        case isp = "ISP"
        public var description: String { return self.rawValue }
    }

    public enum MetricNamespace: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case vdm = "VDM"
        public var description: String { return self.rawValue }
    }

    public enum QueryErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case internalFailure = "INTERNAL_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationImpact: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fixed = "FIXED"
        case open = "OPEN"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bimi = "BIMI"
        case complaint = "COMPLAINT"
        case dkim = "DKIM"
        case dmarc = "DMARC"
        case spf = "SPF"
        public var description: String { return self.rawValue }
    }

    public enum ReviewStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case denied = "DENIED"
        case failed = "FAILED"
        case granted = "GRANTED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ScalingMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case managed = "MANAGED"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case optIn = "OPT_IN"
        case optOut = "OPT_OUT"
        public var description: String { return self.rawValue }
    }

    public enum SuppressionListImportAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        case put = "PUT"
        public var description: String { return self.rawValue }
    }

    public enum SuppressionListReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bounce = "BOUNCE"
        case complaint = "COMPLAINT"
        public var description: String { return self.rawValue }
    }

    public enum TlsPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case optional = "OPTIONAL"
        case require = "REQUIRE"
        public var description: String { return self.rawValue }
    }

    public enum VerificationError: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dnsServerError = "DNS_SERVER_ERROR"
        case hostNotFound = "HOST_NOT_FOUND"
        case invalidValue = "INVALID_VALUE"
        case replicationAccessDenied = "REPLICATION_ACCESS_DENIED"
        case replicationPrimaryByoDkimNotSupported = "REPLICATION_PRIMARY_BYO_DKIM_NOT_SUPPORTED"
        case replicationPrimaryInvalidRegion = "REPLICATION_PRIMARY_INVALID_REGION"
        case replicationPrimaryNotFound = "REPLICATION_PRIMARY_NOT_FOUND"
        case replicationReplicaAsPrimaryNotSupported = "REPLICATION_REPLICA_AS_PRIMARY_NOT_SUPPORTED"
        case serviceError = "SERVICE_ERROR"
        case typeNotFound = "TYPE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum VerificationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case notStarted = "NOT_STARTED"
        case pending = "PENDING"
        case success = "SUCCESS"
        case temporaryFailure = "TEMPORARY_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum WarmupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case done = "DONE"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountDetails: AWSDecodableShape {
        /// Additional email addresses where updates are sent about your account review process.
        public let additionalContactEmailAddresses: [String]?
        /// The language you would prefer for the case. The contact language can be one of ENGLISH or JAPANESE.
        public let contactLanguage: ContactLanguage?
        /// The type of email your account is sending. The mail type can be one of the following:    MARKETING – Most of your sending traffic is to keep your customers informed of your latest offering.    TRANSACTIONAL – Most of your sending traffic is to communicate during a transaction with a customer.
        public let mailType: MailType?
        /// Information about the review of the latest details you submitted.
        public let reviewDetails: ReviewDetails?
        /// A description of the types of email that you plan to send.
        public let useCaseDescription: String?
        /// The URL of your website. This information helps us better understand the type of content that you plan to send.
        public let websiteURL: String?

        @inlinable
        public init(additionalContactEmailAddresses: [String]? = nil, contactLanguage: ContactLanguage? = nil, mailType: MailType? = nil, reviewDetails: ReviewDetails? = nil, useCaseDescription: String? = nil, websiteURL: String? = nil) {
            self.additionalContactEmailAddresses = additionalContactEmailAddresses
            self.contactLanguage = contactLanguage
            self.mailType = mailType
            self.reviewDetails = reviewDetails
            self.useCaseDescription = useCaseDescription
            self.websiteURL = websiteURL
        }

        private enum CodingKeys: String, CodingKey {
            case additionalContactEmailAddresses = "AdditionalContactEmailAddresses"
            case contactLanguage = "ContactLanguage"
            case mailType = "MailType"
            case reviewDetails = "ReviewDetails"
            case useCaseDescription = "UseCaseDescription"
            case websiteURL = "WebsiteURL"
        }
    }

    public struct ArchivingOptions: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the MailManager archive where the Amazon SES API v2 will archive sent emails.
        public let archiveArn: String?

        @inlinable
        public init(archiveArn: String? = nil) {
            self.archiveArn = archiveArn
        }

        public func validate(name: String) throws {
            try self.validate(self.archiveArn, name: "archiveArn", parent: name, max: 1011)
            try self.validate(self.archiveArn, name: "archiveArn", parent: name, min: 20)
            try self.validate(self.archiveArn, name: "archiveArn", parent: name, pattern: "^arn:(aws|aws-[a-z-]+):ses:[a-z]{2}-[a-z-]+-[0-9]:[0-9]{1,20}:mailmanager-archive/a-[a-z0-9]{24,62}$")
        }

        private enum CodingKeys: String, CodingKey {
            case archiveArn = "ArchiveArn"
        }
    }

    public struct Body: AWSEncodableShape {
        /// An object that represents the version of the message that is displayed in email clients that support HTML. HTML messages can include formatted text, hyperlinks, images, and more.
        public let html: Content?
        /// An object that represents the version of the message that is displayed in email clients that don't support HTML, or clients where the recipient has disabled HTML rendering.
        public let text: Content?

        @inlinable
        public init(html: Content? = nil, text: Content? = nil) {
            self.html = html
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case html = "Html"
            case text = "Text"
        }
    }

    public struct Bounce: AWSDecodableShape {
        /// The subtype of the bounce, as determined by SES.
        public let bounceSubType: String?
        /// The type of the bounce, as determined by SES. Can be one of UNDETERMINED, TRANSIENT, or PERMANENT
        public let bounceType: BounceType?
        /// The status code issued by the reporting Message Transfer Authority (MTA). This field only appears if a delivery status notification (DSN) was attached to the bounce and the Diagnostic-Code was provided in the DSN.
        public let diagnosticCode: String?

        @inlinable
        public init(bounceSubType: String? = nil, bounceType: BounceType? = nil, diagnosticCode: String? = nil) {
            self.bounceSubType = bounceSubType
            self.bounceType = bounceType
            self.diagnosticCode = diagnosticCode
        }

        private enum CodingKeys: String, CodingKey {
            case bounceSubType = "BounceSubType"
            case bounceType = "BounceType"
            case diagnosticCode = "DiagnosticCode"
        }
    }

    public struct BulkEmailContent: AWSEncodableShape {
        /// The template to use for the bulk email message.
        public let template: Template?

        @inlinable
        public init(template: Template? = nil) {
            self.template = template
        }

        public func validate(name: String) throws {
            try self.template?.validate(name: "\(name).template")
        }

        private enum CodingKeys: String, CodingKey {
            case template = "Template"
        }
    }

    public struct BulkEmailEntry: AWSEncodableShape {
        /// Represents the destination of the message, consisting of To:, CC:, and BCC: fields.  Amazon SES does not support the SMTPUTF8 extension, as described in RFC6531. For this reason, the local part of a destination email address (the part of the email address that precedes the @ sign) may only contain 7-bit ASCII characters. If the domain part of an address (the part after the @ sign) contains non-ASCII characters, they must be encoded using Punycode, as described in RFC3492.
        public let destination: Destination
        /// The ReplacementEmailContent associated with a BulkEmailEntry.
        public let replacementEmailContent: ReplacementEmailContent?
        /// The list of message headers associated with the BulkEmailEntry data type.   Headers Not Present in BulkEmailEntry: If a header is specified in  Template but not in BulkEmailEntry, the header from Template will be added to the outgoing email.   Headers Present in BulkEmailEntry: If a header is specified in BulkEmailEntry, it takes precedence over any header of the same name specified in  Template :   If the header is also defined within Template, the value from BulkEmailEntry will replace the header's value in the email.   If the header is not defined within Template, it will simply be added to the email as specified in BulkEmailEntry.
        public let replacementHeaders: [MessageHeader]?
        /// A list of tags, in the form of name/value pairs, to apply to an email that you send using the SendBulkTemplatedEmail operation. Tags correspond to characteristics of the email that you define, so that you can publish email sending events.
        public let replacementTags: [MessageTag]?

        @inlinable
        public init(destination: Destination, replacementEmailContent: ReplacementEmailContent? = nil, replacementHeaders: [MessageHeader]? = nil, replacementTags: [MessageTag]? = nil) {
            self.destination = destination
            self.replacementEmailContent = replacementEmailContent
            self.replacementHeaders = replacementHeaders
            self.replacementTags = replacementTags
        }

        public func validate(name: String) throws {
            try self.replacementEmailContent?.validate(name: "\(name).replacementEmailContent")
            try self.replacementHeaders?.forEach {
                try $0.validate(name: "\(name).replacementHeaders[]")
            }
            try self.validate(self.replacementHeaders, name: "replacementHeaders", parent: name, max: 15)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case replacementEmailContent = "ReplacementEmailContent"
            case replacementHeaders = "ReplacementHeaders"
            case replacementTags = "ReplacementTags"
        }
    }

    public struct BulkEmailEntryResult: AWSDecodableShape {
        /// A description of an error that prevented a message being sent using the SendBulkTemplatedEmail operation.
        public let error: String?
        /// The unique message identifier returned from the SendBulkTemplatedEmail operation.
        public let messageId: String?
        /// The status of a message sent using the SendBulkTemplatedEmail operation. Possible values for this parameter include:   SUCCESS: Amazon SES accepted the message, and will attempt to deliver it to the recipients.   MESSAGE_REJECTED: The message was rejected because it contained a virus.   MAIL_FROM_DOMAIN_NOT_VERIFIED: The sender's email address or domain was not verified.   CONFIGURATION_SET_DOES_NOT_EXIST: The configuration set you specified does not exist.   TEMPLATE_DOES_NOT_EXIST: The template you specified does not exist.   ACCOUNT_SUSPENDED: Your account has been shut down because of issues related to your email sending practices.   ACCOUNT_THROTTLED: The number of emails you can send has been reduced because your account has exceeded its allocated sending limit.   ACCOUNT_DAILY_QUOTA_EXCEEDED: You have reached or exceeded the maximum number of emails you can send from your account in a 24-hour period.   INVALID_SENDING_POOL_NAME: The configuration set you specified refers to an IP pool that does not exist.   ACCOUNT_SENDING_PAUSED: Email sending for the Amazon SES account was disabled using the UpdateAccountSendingEnabled operation.   CONFIGURATION_SET_SENDING_PAUSED: Email sending for this configuration set was disabled using the UpdateConfigurationSetSendingEnabled operation.   INVALID_PARAMETER_VALUE: One or more of the parameters you specified when calling this operation was invalid. See the error message for additional information.   TRANSIENT_FAILURE: Amazon SES was unable to process your request because of a temporary issue.   FAILED: Amazon SES was unable to process your request. See the error message for additional information.
        public let status: BulkEmailStatus?

        @inlinable
        public init(error: String? = nil, messageId: String? = nil, status: BulkEmailStatus? = nil) {
            self.error = error
            self.messageId = messageId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case messageId = "MessageId"
            case status = "Status"
        }
    }

    public struct CancelExportJobRequest: AWSEncodableShape {
        /// The export job ID.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "JobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelExportJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CloudWatchDestination: AWSEncodableShape & AWSDecodableShape {
        /// An array of objects that define the dimensions to use when you send email events to Amazon CloudWatch.
        public let dimensionConfigurations: [CloudWatchDimensionConfiguration]

        @inlinable
        public init(dimensionConfigurations: [CloudWatchDimensionConfiguration]) {
            self.dimensionConfigurations = dimensionConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionConfigurations = "DimensionConfigurations"
        }
    }

    public struct CloudWatchDimensionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The default value of the dimension that is published to Amazon CloudWatch if you don't provide the value of the dimension when you send an email. This value has to meet the following criteria:   Can only contain ASCII letters (a–z, A–Z), numbers (0–9), underscores (_), or dashes (-), at signs (@), and periods (.).   It can contain no more than 256 characters.
        public let defaultDimensionValue: String
        /// The name of an Amazon CloudWatch dimension associated with an email sending metric. The name has to meet the following criteria:   It can only contain ASCII letters (a–z, A–Z), numbers (0–9), underscores (_), or dashes (-).   It can contain no more than 256 characters.
        public let dimensionName: String
        /// The location where the Amazon SES API v2 finds the value of a dimension to publish to Amazon CloudWatch. To use the message tags that you specify using an X-SES-MESSAGE-TAGS header or a parameter to the SendEmail or SendRawEmail API, choose messageTag. To use your own email headers, choose emailHeader. To use link tags, choose linkTags.
        public let dimensionValueSource: DimensionValueSource

        @inlinable
        public init(defaultDimensionValue: String, dimensionName: String, dimensionValueSource: DimensionValueSource) {
            self.defaultDimensionValue = defaultDimensionValue
            self.dimensionName = dimensionName
            self.dimensionValueSource = dimensionValueSource
        }

        private enum CodingKeys: String, CodingKey {
            case defaultDimensionValue = "DefaultDimensionValue"
            case dimensionName = "DimensionName"
            case dimensionValueSource = "DimensionValueSource"
        }
    }

    public struct Complaint: AWSDecodableShape {
        ///  The value of the Feedback-Type field from the feedback report received from the ISP.
        public let complaintFeedbackType: String?
        ///  Can either be null or OnAccountSuppressionList. If the value is OnAccountSuppressionList, SES accepted the message, but didn't attempt to send it because it was on the account-level suppression list.
        public let complaintSubType: String?

        @inlinable
        public init(complaintFeedbackType: String? = nil, complaintSubType: String? = nil) {
            self.complaintFeedbackType = complaintFeedbackType
            self.complaintSubType = complaintSubType
        }

        private enum CodingKeys: String, CodingKey {
            case complaintFeedbackType = "ComplaintFeedbackType"
            case complaintSubType = "ComplaintSubType"
        }
    }

    public struct Contact: AWSDecodableShape {
        /// The contact's email address.
        public let emailAddress: String?
        /// A timestamp noting the last time the contact's information was updated.
        public let lastUpdatedTimestamp: Date?
        /// The default topic preferences applied to the contact.
        public let topicDefaultPreferences: [TopicPreference]?
        /// The contact's preference for being opted-in to or opted-out of a topic.
        public let topicPreferences: [TopicPreference]?
        /// A boolean value status noting if the contact is unsubscribed from all contact list topics.
        public let unsubscribeAll: Bool?

        @inlinable
        public init(emailAddress: String? = nil, lastUpdatedTimestamp: Date? = nil, topicDefaultPreferences: [TopicPreference]? = nil, topicPreferences: [TopicPreference]? = nil, unsubscribeAll: Bool? = nil) {
            self.emailAddress = emailAddress
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.topicDefaultPreferences = topicDefaultPreferences
            self.topicPreferences = topicPreferences
            self.unsubscribeAll = unsubscribeAll
        }

        private enum CodingKeys: String, CodingKey {
            case emailAddress = "EmailAddress"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case topicDefaultPreferences = "TopicDefaultPreferences"
            case topicPreferences = "TopicPreferences"
            case unsubscribeAll = "UnsubscribeAll"
        }
    }

    public struct ContactList: AWSDecodableShape {
        /// The name of the contact list.
        public let contactListName: String?
        /// A timestamp noting the last time the contact list was updated.
        public let lastUpdatedTimestamp: Date?

        @inlinable
        public init(contactListName: String? = nil, lastUpdatedTimestamp: Date? = nil) {
            self.contactListName = contactListName
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case contactListName = "ContactListName"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        }
    }

    public struct Content: AWSEncodableShape {
        /// The character set for the content. Because of the constraints of the SMTP protocol, Amazon SES uses 7-bit ASCII by default. If the text includes characters outside of the ASCII range, you have to specify a character set. For example, you could specify UTF-8, ISO-8859-1, or Shift_JIS.
        public let charset: String?
        /// The content of the message itself.
        public let data: String

        @inlinable
        public init(charset: String? = nil, data: String) {
            self.charset = charset
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case charset = "Charset"
            case data = "Data"
        }
    }

    public struct DedicatedIp: AWSDecodableShape {
        /// An IPv4 address.
        public let ip: String
        /// The name of the dedicated IP pool that the IP address is associated with.
        public let poolName: String?
        /// Indicates how complete the dedicated IP warm-up process is. When this value equals 1, the address has completed the warm-up process and is ready for use.
        public let warmupPercentage: Int
        /// The warm-up status of a dedicated IP address. The status can have one of the following values:    IN_PROGRESS – The IP address isn't ready to use because the dedicated IP warm-up process is ongoing.    DONE – The dedicated IP warm-up process is complete, and the IP address is ready to use.
        public let warmupStatus: WarmupStatus

        @inlinable
        public init(ip: String, poolName: String? = nil, warmupPercentage: Int, warmupStatus: WarmupStatus) {
            self.ip = ip
            self.poolName = poolName
            self.warmupPercentage = warmupPercentage
            self.warmupStatus = warmupStatus
        }

        private enum CodingKeys: String, CodingKey {
            case ip = "Ip"
            case poolName = "PoolName"
            case warmupPercentage = "WarmupPercentage"
            case warmupStatus = "WarmupStatus"
        }
    }

    public struct DedicatedIpPool: AWSDecodableShape {
        /// The name of the dedicated IP pool.
        public let poolName: String
        /// The type of the dedicated IP pool.    STANDARD – A dedicated IP pool where you can control which IPs are part of the pool.    MANAGED – A dedicated IP pool where the reputation and number of IPs are automatically managed by Amazon SES.
        public let scalingMode: ScalingMode

        @inlinable
        public init(poolName: String, scalingMode: ScalingMode) {
            self.poolName = poolName
            self.scalingMode = scalingMode
        }

        private enum CodingKeys: String, CodingKey {
            case poolName = "PoolName"
            case scalingMode = "ScalingMode"
        }
    }

    public struct DeliveryOptions: AWSEncodableShape & AWSDecodableShape {
        /// The maximum amount of time, in seconds, that Amazon SES API v2 will attempt delivery of email. If specified, the value must greater than or equal to 300 seconds (5 minutes) and less than or equal to 50400 seconds (840 minutes).
        public let maxDeliverySeconds: Int64?
        /// The name of the dedicated IP pool to associate with the configuration set.
        public let sendingPoolName: String?
        /// Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). If the value is Require, messages are only delivered if a TLS connection can be established. If the value is Optional, messages can be delivered in plain text if a TLS connection can't be established.
        public let tlsPolicy: TlsPolicy?

        @inlinable
        public init(maxDeliverySeconds: Int64? = nil, sendingPoolName: String? = nil, tlsPolicy: TlsPolicy? = nil) {
            self.maxDeliverySeconds = maxDeliverySeconds
            self.sendingPoolName = sendingPoolName
            self.tlsPolicy = tlsPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.maxDeliverySeconds, name: "maxDeliverySeconds", parent: name, max: 50400)
            try self.validate(self.maxDeliverySeconds, name: "maxDeliverySeconds", parent: name, min: 300)
        }

        private enum CodingKeys: String, CodingKey {
            case maxDeliverySeconds = "MaxDeliverySeconds"
            case sendingPoolName = "SendingPoolName"
            case tlsPolicy = "TlsPolicy"
        }
    }

    public struct Destination: AWSEncodableShape {
        /// An array that contains the email addresses of the "BCC" (blind carbon copy) recipients for the email.
        public let bccAddresses: [String]?
        /// An array that contains the email addresses of the "CC" (carbon copy) recipients for the email.
        public let ccAddresses: [String]?
        /// An array that contains the email addresses of the "To" recipients for the email.
        public let toAddresses: [String]?

        @inlinable
        public init(bccAddresses: [String]? = nil, ccAddresses: [String]? = nil, toAddresses: [String]? = nil) {
            self.bccAddresses = bccAddresses
            self.ccAddresses = ccAddresses
            self.toAddresses = toAddresses
        }

        private enum CodingKeys: String, CodingKey {
            case bccAddresses = "BccAddresses"
            case ccAddresses = "CcAddresses"
            case toAddresses = "ToAddresses"
        }
    }

    public struct Details: AWSEncodableShape {
        /// A list of route configuration details. Must contain exactly one route configuration.
        public let routesDetails: [RouteDetails]

        @inlinable
        public init(routesDetails: [RouteDetails]) {
            self.routesDetails = routesDetails
        }

        private enum CodingKeys: String, CodingKey {
            case routesDetails = "RoutesDetails"
        }
    }

    public struct DomainDeliverabilityCampaign: AWSDecodableShape {
        /// The unique identifier for the campaign. The Deliverability dashboard automatically generates and assigns this identifier to a campaign.
        public let campaignId: String?
        /// The percentage of email messages that were deleted by recipients, without being opened first. Due to technical limitations, this value only includes recipients who opened the message by using an email client that supports images.
        public let deleteRate: Double?
        /// The major email providers who handled the email message.
        public let esps: [String]?
        /// The first time when the email message was delivered to any recipient's inbox. This value can help you determine how long it took for a campaign to deliver an email message.
        public let firstSeenDateTime: Date?
        /// The verified email address that the email message was sent from.
        public let fromAddress: String?
        /// The URL of an image that contains a snapshot of the email message that was sent.
        public let imageUrl: String?
        /// The number of email messages that were delivered to recipients’ inboxes.
        public let inboxCount: Int64?
        /// The last time when the email message was delivered to any recipient's inbox. This value can help you determine how long it took for a campaign to deliver an email message.
        public let lastSeenDateTime: Date?
        /// The projected number of recipients that the email message was sent to.
        public let projectedVolume: Int64?
        /// The percentage of email messages that were opened and then deleted by recipients. Due to technical limitations, this value only includes recipients who opened the message by using an email client that supports images.
        public let readDeleteRate: Double?
        /// The percentage of email messages that were opened by recipients. Due to technical limitations, this value only includes recipients who opened the message by using an email client that supports images.
        public let readRate: Double?
        /// The IP addresses that were used to send the email message.
        public let sendingIps: [String]?
        /// The number of email messages that were delivered to recipients' spam or junk mail folders.
        public let spamCount: Int64?
        /// The subject line, or title, of the email message.
        public let subject: String?

        @inlinable
        public init(campaignId: String? = nil, deleteRate: Double? = nil, esps: [String]? = nil, firstSeenDateTime: Date? = nil, fromAddress: String? = nil, imageUrl: String? = nil, inboxCount: Int64? = nil, lastSeenDateTime: Date? = nil, projectedVolume: Int64? = nil, readDeleteRate: Double? = nil, readRate: Double? = nil, sendingIps: [String]? = nil, spamCount: Int64? = nil, subject: String? = nil) {
            self.campaignId = campaignId
            self.deleteRate = deleteRate
            self.esps = esps
            self.firstSeenDateTime = firstSeenDateTime
            self.fromAddress = fromAddress
            self.imageUrl = imageUrl
            self.inboxCount = inboxCount
            self.lastSeenDateTime = lastSeenDateTime
            self.projectedVolume = projectedVolume
            self.readDeleteRate = readDeleteRate
            self.readRate = readRate
            self.sendingIps = sendingIps
            self.spamCount = spamCount
            self.subject = subject
        }

        private enum CodingKeys: String, CodingKey {
            case campaignId = "CampaignId"
            case deleteRate = "DeleteRate"
            case esps = "Esps"
            case firstSeenDateTime = "FirstSeenDateTime"
            case fromAddress = "FromAddress"
            case imageUrl = "ImageUrl"
            case inboxCount = "InboxCount"
            case lastSeenDateTime = "LastSeenDateTime"
            case projectedVolume = "ProjectedVolume"
            case readDeleteRate = "ReadDeleteRate"
            case readRate = "ReadRate"
            case sendingIps = "SendingIps"
            case spamCount = "SpamCount"
            case subject = "Subject"
        }
    }

    public struct DomainDeliverabilityTrackingOption: AWSEncodableShape & AWSDecodableShape {
        /// A verified domain that’s associated with your Amazon Web Services account and currently has an active Deliverability dashboard subscription.
        public let domain: String?
        /// An object that contains information about the inbox placement data settings for the domain.
        public let inboxPlacementTrackingOption: InboxPlacementTrackingOption?
        /// The date when you enabled the Deliverability dashboard for the domain.
        public let subscriptionStartDate: Date?

        @inlinable
        public init(domain: String? = nil, inboxPlacementTrackingOption: InboxPlacementTrackingOption? = nil, subscriptionStartDate: Date? = nil) {
            self.domain = domain
            self.inboxPlacementTrackingOption = inboxPlacementTrackingOption
            self.subscriptionStartDate = subscriptionStartDate
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
            case inboxPlacementTrackingOption = "InboxPlacementTrackingOption"
            case subscriptionStartDate = "SubscriptionStartDate"
        }
    }

    public struct DomainIspPlacement: AWSDecodableShape {
        /// The percentage of messages that were sent from the selected domain to the specified email provider that arrived in recipients' inboxes.
        public let inboxPercentage: Double?
        /// The total number of messages that were sent from the selected domain to the specified email provider that arrived in recipients' inboxes.
        public let inboxRawCount: Int64?
        /// The name of the email provider that the inbox placement data applies to.
        public let ispName: String?
        /// The percentage of messages that were sent from the selected domain to the specified email provider that arrived in recipients' spam or junk mail folders.
        public let spamPercentage: Double?
        /// The total number of messages that were sent from the selected domain to the specified email provider that arrived in recipients' spam or junk mail folders.
        public let spamRawCount: Int64?

        @inlinable
        public init(inboxPercentage: Double? = nil, inboxRawCount: Int64? = nil, ispName: String? = nil, spamPercentage: Double? = nil, spamRawCount: Int64? = nil) {
            self.inboxPercentage = inboxPercentage
            self.inboxRawCount = inboxRawCount
            self.ispName = ispName
            self.spamPercentage = spamPercentage
            self.spamRawCount = spamRawCount
        }

        private enum CodingKeys: String, CodingKey {
            case inboxPercentage = "InboxPercentage"
            case inboxRawCount = "InboxRawCount"
            case ispName = "IspName"
            case spamPercentage = "SpamPercentage"
            case spamRawCount = "SpamRawCount"
        }
    }

    public struct EmailContent: AWSEncodableShape {
        /// The raw email message. The message has to meet the following criteria:   The message has to contain a header and a body, separated by one blank line.   All of the required header fields must be present in the message.   Each part of a multipart MIME message must be formatted properly.   If you include attachments, they must be in a file format that the Amazon SES API v2 supports.    The raw data of the message needs to base64-encoded if you are accessing Amazon SES directly through the HTTPS interface. If you are accessing Amazon SES using an Amazon Web Services SDK, the SDK takes care of the base 64-encoding for you.   If any of the MIME parts in your message contain content that is outside of the 7-bit ASCII character range, you should encode that content to ensure that recipients' email clients render the message properly.   The length of any single line of text in the message can't exceed 1,000 characters. This restriction is defined in RFC 5321.
        public let raw: RawMessage?
        /// The simple email message. The message consists of a subject and a message body.
        public let simple: Message?
        /// The template to use for the email message.
        public let template: Template?

        @inlinable
        public init(raw: RawMessage? = nil, simple: Message? = nil, template: Template? = nil) {
            self.raw = raw
            self.simple = simple
            self.template = template
        }

        public func validate(name: String) throws {
            try self.simple?.validate(name: "\(name).simple")
            try self.template?.validate(name: "\(name).template")
        }

        private enum CodingKeys: String, CodingKey {
            case raw = "Raw"
            case simple = "Simple"
            case template = "Template"
        }
    }

    public struct EmailInsights: AWSDecodableShape {
        /// The recipient of the email.
        public let destination: String?
        /// A list of events associated with the sent email.
        public let events: [InsightsEvent]?
        /// The recipient's ISP (e.g., Gmail, Yahoo, etc.).
        public let isp: String?

        @inlinable
        public init(destination: String? = nil, events: [InsightsEvent]? = nil, isp: String? = nil) {
            self.destination = destination
            self.events = events
            self.isp = isp
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case events = "Events"
            case isp = "Isp"
        }
    }

    public struct EmailTemplateContent: AWSEncodableShape & AWSDecodableShape {
        /// The HTML body of the email.
        public let html: String?
        /// The subject line of the email.
        public let subject: String?
        /// The email body that will be visible to recipients whose email clients do not display HTML.
        public let text: String?

        @inlinable
        public init(html: String? = nil, subject: String? = nil, text: String? = nil) {
            self.html = html
            self.subject = subject
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case html = "Html"
            case subject = "Subject"
            case text = "Text"
        }
    }

    public struct EmailTemplateMetadata: AWSDecodableShape {
        /// The time and date the template was created.
        public let createdTimestamp: Date?
        /// The name of the template.
        public let templateName: String?

        @inlinable
        public init(createdTimestamp: Date? = nil, templateName: String? = nil) {
            self.createdTimestamp = createdTimestamp
            self.templateName = templateName
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case templateName = "TemplateName"
        }
    }

    public struct EventBridgeDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon EventBridge bus to publish email events to. Only the default bus is supported.
        public let eventBusArn: String

        @inlinable
        public init(eventBusArn: String) {
            self.eventBusArn = eventBusArn
        }

        private enum CodingKeys: String, CodingKey {
            case eventBusArn = "EventBusArn"
        }
    }

    public struct EventDetails: AWSDecodableShape {
        /// Information about a Bounce event.
        public let bounce: Bounce?
        /// Information about a Complaint event.
        public let complaint: Complaint?

        @inlinable
        public init(bounce: Bounce? = nil, complaint: Complaint? = nil) {
            self.bounce = bounce
            self.complaint = complaint
        }

        private enum CodingKeys: String, CodingKey {
            case bounce = "Bounce"
            case complaint = "Complaint"
        }
    }

    public struct FailureInfo: AWSDecodableShape {
        /// A message about why the job failed.
        public let errorMessage: String?
        /// An Amazon S3 pre-signed URL that contains all the failed records and related information.
        public let failedRecordsS3Url: String?

        @inlinable
        public init(errorMessage: String? = nil, failedRecordsS3Url: String? = nil) {
            self.errorMessage = errorMessage
            self.failedRecordsS3Url = failedRecordsS3Url
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case failedRecordsS3Url = "FailedRecordsS3Url"
        }
    }

    public struct IdentityInfo: AWSDecodableShape {
        /// The address or domain of the identity.
        public let identityName: String?
        /// The email identity type. Note: the MANAGED_DOMAIN type is not supported for email identity types.
        public let identityType: IdentityType?
        /// Indicates whether or not you can send email from the identity. An identity is an email address or domain that you send email from. Before you can send email from an identity, you have to demostrate that you own the identity, and that you authorize Amazon SES to send email from that identity.
        public let sendingEnabled: Bool?
        /// The verification status of the identity. The status can be one of the following:    PENDING – The verification process was initiated, but Amazon SES hasn't yet been able to verify the identity.    SUCCESS – The verification process completed successfully.    FAILED – The verification process failed.    TEMPORARY_FAILURE – A temporary issue is preventing Amazon SES from determining the verification status of the identity.    NOT_STARTED – The verification process hasn't been initiated for the identity.
        public let verificationStatus: VerificationStatus?

        @inlinable
        public init(identityName: String? = nil, identityType: IdentityType? = nil, sendingEnabled: Bool? = nil, verificationStatus: VerificationStatus? = nil) {
            self.identityName = identityName
            self.identityType = identityType
            self.sendingEnabled = sendingEnabled
            self.verificationStatus = verificationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case identityName = "IdentityName"
            case identityType = "IdentityType"
            case sendingEnabled = "SendingEnabled"
            case verificationStatus = "VerificationStatus"
        }
    }

    public struct InboxPlacementTrackingOption: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether inbox placement data is being tracked for the domain.
        public let global: Bool?
        /// An array of strings, one for each major email provider that the inbox placement data applies to.
        public let trackedIsps: [String]?

        @inlinable
        public init(global: Bool? = nil, trackedIsps: [String]? = nil) {
            self.global = global
            self.trackedIsps = trackedIsps
        }

        private enum CodingKeys: String, CodingKey {
            case global = "Global"
            case trackedIsps = "TrackedIsps"
        }
    }

    public struct InsightsEvent: AWSDecodableShape {
        /// Details about bounce or complaint events.
        public let details: EventDetails?
        /// The timestamp of the event.
        public let timestamp: Date?
        /// The type of event:    SEND - The send request was successful and SES will attempt to deliver the message to the recipient’s mail server. (If account-level or global suppression is being used, SES will still count it as a send, but delivery is suppressed.)     DELIVERY - SES successfully delivered the email to the recipient's mail server. Excludes deliveries to the mailbox simulator, and those from emails addressed to more than one recipient.     BOUNCE - Feedback received for delivery failures. Additional details about the bounce are provided in the Details object. Excludes bounces from the mailbox simulator, and those from emails addressed to more than one recipient.     COMPLAINT - Complaint received for the email. Additional details about the complaint are provided in the Details object. This excludes complaints from the mailbox simulator, those originating from your account-level suppression list (if enabled), and those from emails addressed to more than one recipient.     OPEN - Open event for emails including open trackers. Excludes opens for emails addressed to more than one recipient.    CLICK - Click event for emails including wrapped links. Excludes clicks for emails addressed to more than one recipient.
        public let type: EventType?

        @inlinable
        public init(details: EventDetails? = nil, timestamp: Date? = nil, type: EventType? = nil) {
            self.details = details
            self.timestamp = timestamp
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "Details"
            case timestamp = "Timestamp"
            case type = "Type"
        }
    }

    public struct ListManagementOptions: AWSEncodableShape {
        /// The name of the contact list.
        public let contactListName: String
        /// The name of the topic.
        public let topicName: String?

        @inlinable
        public init(contactListName: String, topicName: String? = nil) {
            self.contactListName = contactListName
            self.topicName = topicName
        }

        private enum CodingKeys: String, CodingKey {
            case contactListName = "ContactListName"
            case topicName = "TopicName"
        }
    }

    public struct MailFromAttributes: AWSDecodableShape {
        /// The action to take if the required MX record can't be found when you send an email. When you set this value to USE_DEFAULT_VALUE, the mail is sent using amazonses.com as the MAIL FROM domain. When you set this value to REJECT_MESSAGE, the Amazon SES API v2 returns a MailFromDomainNotVerified error, and doesn't attempt to deliver the email. These behaviors are taken when the custom MAIL FROM domain configuration is in the Pending, Failed, and TemporaryFailure states.
        public let behaviorOnMxFailure: BehaviorOnMxFailure
        /// The name of a domain that an email identity uses as a custom MAIL FROM domain.
        public let mailFromDomain: String
        /// The status of the MAIL FROM domain. This status can have the following values:    PENDING – Amazon SES hasn't started searching for the MX record yet.    SUCCESS – Amazon SES detected the required MX record for the MAIL FROM domain.    FAILED – Amazon SES can't find the required MX record, or the record no longer exists.    TEMPORARY_FAILURE – A temporary issue occurred, which prevented Amazon SES from determining the status of the MAIL FROM domain.
        public let mailFromDomainStatus: MailFromDomainStatus

        @inlinable
        public init(behaviorOnMxFailure: BehaviorOnMxFailure, mailFromDomain: String, mailFromDomainStatus: MailFromDomainStatus) {
            self.behaviorOnMxFailure = behaviorOnMxFailure
            self.mailFromDomain = mailFromDomain
            self.mailFromDomainStatus = mailFromDomainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case behaviorOnMxFailure = "BehaviorOnMxFailure"
            case mailFromDomain = "MailFromDomain"
            case mailFromDomainStatus = "MailFromDomainStatus"
        }
    }

    public struct Message: AWSEncodableShape {
        /// The body of the message. You can specify an HTML version of the message, a text-only version of the message, or both.
        public let body: Body
        /// The list of message headers that will be added to the email message.
        public let headers: [MessageHeader]?
        /// The subject line of the email. The subject line can only contain 7-bit ASCII characters. However, you can specify non-ASCII characters in the subject line by using encoded-word syntax, as described in RFC 2047.
        public let subject: Content

        @inlinable
        public init(body: Body, headers: [MessageHeader]? = nil, subject: Content) {
            self.body = body
            self.headers = headers
            self.subject = subject
        }

        public func validate(name: String) throws {
            try self.headers?.forEach {
                try $0.validate(name: "\(name).headers[]")
            }
            try self.validate(self.headers, name: "headers", parent: name, max: 15)
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case headers = "Headers"
            case subject = "Subject"
        }
    }

    public struct MessageHeader: AWSEncodableShape {
        /// The name of the message header. The message header name has to meet the following criteria:   Can contain any printable ASCII character (33 - 126) except for colon (:).   Can contain no more than 126 characters.
        public let name: String
        /// The value of the message header. The message header value has to meet the following criteria:   Can contain any printable ASCII character.   Can contain no more than 870 characters.
        public let value: String

        @inlinable
        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 126)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[!-9;-@A-~]+$")
            try self.validate(self.value, name: "value", parent: name, max: 870)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[ -~]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct MessageInsightsDataSource: AWSEncodableShape & AWSDecodableShape {
        /// Represents the end date for the export interval as a timestamp. The end date is inclusive.
        public let endDate: Date
        /// Filters for results to be excluded from the export file.
        public let exclude: MessageInsightsFilters?
        /// Filters for results to be included in the export file.
        public let include: MessageInsightsFilters?
        /// The maximum number of results.
        public let maxResults: Int?
        /// Represents the start date for the export interval as a timestamp. The start date is inclusive.
        public let startDate: Date

        @inlinable
        public init(endDate: Date, exclude: MessageInsightsFilters? = nil, include: MessageInsightsFilters? = nil, maxResults: Int? = nil, startDate: Date) {
            self.endDate = endDate
            self.exclude = exclude
            self.include = include
            self.maxResults = maxResults
            self.startDate = startDate
        }

        public func validate(name: String) throws {
            try self.exclude?.validate(name: "\(name).exclude")
            try self.include?.validate(name: "\(name).include")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "EndDate"
            case exclude = "Exclude"
            case include = "Include"
            case maxResults = "MaxResults"
            case startDate = "StartDate"
        }
    }

    public struct MessageInsightsFilters: AWSEncodableShape & AWSDecodableShape {
        /// The recipient's email address.
        public let destination: [String]?
        /// The from address used to send the message.
        public let fromEmailAddress: [String]?
        /// The recipient's ISP (e.g., Gmail, Yahoo, etc.).
        public let isp: [String]?
        ///  The last delivery-related event for the email, where the ordering is as follows: SEND BOUNCE DELIVERY COMPLAINT.
        public let lastDeliveryEvent: [DeliveryEventType]?
        ///  The last engagement-related event for the email, where the ordering is as follows: OPEN CLICK.   Engagement events are only available if Engagement tracking is enabled.
        public let lastEngagementEvent: [EngagementEventType]?
        /// The subject line of the message.
        public let subject: [String]?

        @inlinable
        public init(destination: [String]? = nil, fromEmailAddress: [String]? = nil, isp: [String]? = nil, lastDeliveryEvent: [DeliveryEventType]? = nil, lastEngagementEvent: [EngagementEventType]? = nil, subject: [String]? = nil) {
            self.destination = destination
            self.fromEmailAddress = fromEmailAddress
            self.isp = isp
            self.lastDeliveryEvent = lastDeliveryEvent
            self.lastEngagementEvent = lastEngagementEvent
            self.subject = subject
        }

        public func validate(name: String) throws {
            try self.destination?.forEach {
                try validate($0, name: "destination[]", parent: name, max: 320)
                try validate($0, name: "destination[]", parent: name, min: 1)
            }
            try self.validate(self.destination, name: "destination", parent: name, max: 5)
            try self.fromEmailAddress?.forEach {
                try validate($0, name: "fromEmailAddress[]", parent: name, max: 320)
                try validate($0, name: "fromEmailAddress[]", parent: name, min: 1)
            }
            try self.validate(self.fromEmailAddress, name: "fromEmailAddress", parent: name, max: 5)
            try self.validate(self.isp, name: "isp", parent: name, max: 5)
            try self.validate(self.lastDeliveryEvent, name: "lastDeliveryEvent", parent: name, max: 5)
            try self.validate(self.lastEngagementEvent, name: "lastEngagementEvent", parent: name, max: 2)
            try self.subject?.forEach {
                try validate($0, name: "subject[]", parent: name, max: 998)
                try validate($0, name: "subject[]", parent: name, min: 1)
            }
            try self.validate(self.subject, name: "subject", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case fromEmailAddress = "FromEmailAddress"
            case isp = "Isp"
            case lastDeliveryEvent = "LastDeliveryEvent"
            case lastEngagementEvent = "LastEngagementEvent"
            case subject = "Subject"
        }
    }

    public struct MessageTag: AWSEncodableShape & AWSDecodableShape {
        /// The name of the message tag. The message tag name has to meet the following criteria:   It can only contain ASCII letters (a–z, A–Z), numbers (0–9), underscores (_), or dashes (-).   It can contain no more than 256 characters.
        public let name: String
        /// The value of the message tag. The message tag value has to meet the following criteria:   It can only contain ASCII letters (a–z, A–Z), numbers (0–9), underscores (_), or dashes (-).   It can contain no more than 256 characters.
        public let value: String

        @inlinable
        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct MetricDataError: AWSDecodableShape {
        /// The query error code. Can be one of:    INTERNAL_FAILURE – Amazon SES has failed to process one of the queries.    ACCESS_DENIED – You have insufficient access to retrieve metrics based on the given query.
        public let code: QueryErrorCode?
        /// The query identifier.
        public let id: String?
        /// The error message associated with the current query error.
        public let message: String?

        @inlinable
        public init(code: QueryErrorCode? = nil, id: String? = nil, message: String? = nil) {
            self.code = code
            self.id = id
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case id = "Id"
            case message = "Message"
        }
    }

    public struct MetricDataResult: AWSDecodableShape {
        /// The query identifier.
        public let id: String?
        /// A list of timestamps for the metric data results.
        public let timestamps: [Date]?
        /// A list of values (cumulative / sum) for the metric data results.
        public let values: [Int64]?

        @inlinable
        public init(id: String? = nil, timestamps: [Date]? = nil, values: [Int64]? = nil) {
            self.id = id
            self.timestamps = timestamps
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case timestamps = "Timestamps"
            case values = "Values"
        }
    }

    public struct MultiRegionEndpoint: AWSDecodableShape {
        /// The time stamp of when the multi-region endpoint (global-endpoint) was created.
        public let createdTimestamp: Date?
        /// The ID of the multi-region endpoint (global-endpoint).
        public let endpointId: String?
        /// The name of the multi-region endpoint (global-endpoint).
        public let endpointName: String?
        /// The time stamp of when the multi-region endpoint (global-endpoint) was last updated.
        public let lastUpdatedTimestamp: Date?
        /// Primary and secondary regions between which multi-region endpoint splits sending traffic.
        public let regions: [String]?
        /// The status of the multi-region endpoint (global-endpoint).    CREATING – The resource is being provisioned.    READY – The resource is ready to use.    FAILED – The resource failed to be provisioned.    DELETING – The resource is being deleted as requested.
        public let status: Status?

        @inlinable
        public init(createdTimestamp: Date? = nil, endpointId: String? = nil, endpointName: String? = nil, lastUpdatedTimestamp: Date? = nil, regions: [String]? = nil, status: Status? = nil) {
            self.createdTimestamp = createdTimestamp
            self.endpointId = endpointId
            self.endpointName = endpointName
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.regions = regions
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case endpointId = "EndpointId"
            case endpointName = "EndpointName"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case regions = "Regions"
            case status = "Status"
        }
    }

    public struct RawMessage: AWSEncodableShape {
        /// The raw email message. The message has to meet the following criteria:   The message has to contain a header and a body, separated by one blank line.   All of the required header fields must be present in the message.   Each part of a multipart MIME message must be formatted properly.   Attachments must be in a file format that the Amazon SES supports.   The raw data of the message needs to base64-encoded if you are accessing Amazon SES directly through the HTTPS interface. If you are accessing Amazon SES using an Amazon Web Services SDK, the SDK takes care of the base 64-encoding for you.   If any of the MIME parts in your message contain content that is outside of the 7-bit ASCII character range, you should encode that content to ensure that recipients' email clients render the message properly.   The length of any single line of text in the message can't exceed 1,000 characters. This restriction is defined in RFC 5321.
        public let data: AWSBase64Data

        @inlinable
        public init(data: AWSBase64Data) {
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// The first time this issue was encountered and the recommendation was generated.
        public let createdTimestamp: Date?
        /// The recommendation description / disambiguator - e.g. DKIM1 and DKIM2 are different recommendations about your DKIM setup.
        public let description: String?
        /// The recommendation impact, with values like HIGH or LOW.
        public let impact: RecommendationImpact?
        /// The last time the recommendation was updated.
        public let lastUpdatedTimestamp: Date?
        /// The resource affected by the recommendation, with values like arn:aws:ses:us-east-1:123456789012:identity/example.com.
        public let resourceArn: String?
        /// The recommendation status, with values like OPEN or FIXED.
        public let status: RecommendationStatus?
        /// The recommendation type, with values like DKIM, SPF, DMARC, BIMI, or COMPLAINT.
        public let type: RecommendationType?

        @inlinable
        public init(createdTimestamp: Date? = nil, description: String? = nil, impact: RecommendationImpact? = nil, lastUpdatedTimestamp: Date? = nil, resourceArn: String? = nil, status: RecommendationStatus? = nil, type: RecommendationType? = nil) {
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.impact = impact
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.resourceArn = resourceArn
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case description = "Description"
            case impact = "Impact"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case resourceArn = "ResourceArn"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct ReplacementEmailContent: AWSEncodableShape {
        /// The ReplacementTemplate associated with ReplacementEmailContent.
        public let replacementTemplate: ReplacementTemplate?

        @inlinable
        public init(replacementTemplate: ReplacementTemplate? = nil) {
            self.replacementTemplate = replacementTemplate
        }

        public func validate(name: String) throws {
            try self.replacementTemplate?.validate(name: "\(name).replacementTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case replacementTemplate = "ReplacementTemplate"
        }
    }

    public struct ReplacementTemplate: AWSEncodableShape {
        /// A list of replacement values to apply to the template. This parameter is a JSON object, typically consisting of key-value pairs in which the keys correspond to replacement tags in the email template.
        public let replacementTemplateData: String?

        @inlinable
        public init(replacementTemplateData: String? = nil) {
            self.replacementTemplateData = replacementTemplateData
        }

        public func validate(name: String) throws {
            try self.validate(self.replacementTemplateData, name: "replacementTemplateData", parent: name, max: 262144)
        }

        private enum CodingKeys: String, CodingKey {
            case replacementTemplateData = "ReplacementTemplateData"
        }
    }

    public struct ReputationOptions: AWSEncodableShape & AWSDecodableShape {
        /// The date and time (in Unix time) when the reputation metrics were last given a fresh start. When your account is given a fresh start, your reputation metrics are calculated starting from the date of the fresh start.
        public let lastFreshStart: Date?
        /// If true, tracking of reputation metrics is enabled for the configuration set. If false, tracking of reputation metrics is disabled for the configuration set.
        public let reputationMetricsEnabled: Bool?

        @inlinable
        public init(lastFreshStart: Date? = nil, reputationMetricsEnabled: Bool? = nil) {
            self.lastFreshStart = lastFreshStart
            self.reputationMetricsEnabled = reputationMetricsEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case lastFreshStart = "LastFreshStart"
            case reputationMetricsEnabled = "ReputationMetricsEnabled"
        }
    }

    public struct ReviewDetails: AWSDecodableShape {
        /// The associated support center case ID (if any).
        public let caseId: String?
        /// The status of the latest review of your account. The status can be one of the following:    PENDING – We have received your appeal and are in the process of reviewing it.    GRANTED – Your appeal has been reviewed and your production access has been granted.    DENIED – Your appeal has been reviewed and your production access has been denied.    FAILED – An internal error occurred and we didn't receive your appeal. You can submit your appeal again.
        public let status: ReviewStatus?

        @inlinable
        public init(caseId: String? = nil, status: ReviewStatus? = nil) {
            self.caseId = caseId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case caseId = "CaseId"
            case status = "Status"
        }
    }

    public struct Route: AWSDecodableShape {
        /// The name of an AWS-Region.
        public let region: String

        @inlinable
        public init(region: String) {
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case region = "Region"
        }
    }

    public struct RouteDetails: AWSEncodableShape {
        /// The name of an AWS-Region to be a secondary region for the multi-region endpoint (global-endpoint).
        public let region: String

        @inlinable
        public init(region: String) {
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case region = "Region"
        }
    }

    public struct SOARecord: AWSDecodableShape {
        /// Administrative contact email from the SOA record.
        public let adminEmail: String?
        /// Primary name server specified in the SOA record.
        public let primaryNameServer: String?
        /// Serial number from the SOA record.
        public let serialNumber: Int64?

        @inlinable
        public init(adminEmail: String? = nil, primaryNameServer: String? = nil, serialNumber: Int64? = nil) {
            self.adminEmail = adminEmail
            self.primaryNameServer = primaryNameServer
            self.serialNumber = serialNumber
        }

        private enum CodingKeys: String, CodingKey {
            case adminEmail = "AdminEmail"
            case primaryNameServer = "PrimaryNameServer"
            case serialNumber = "SerialNumber"
        }
    }

    public struct SendBulkEmailRequest: AWSEncodableShape {
        /// The list of bulk email entry objects.
        public let bulkEmailEntries: [BulkEmailEntry]
        /// The name of the configuration set to use when sending the email.
        public let configurationSetName: String?
        /// An object that contains the body of the message. You can specify a template message.
        public let defaultContent: BulkEmailContent
        /// A list of tags, in the form of name/value pairs, to apply to an email that you send using the SendEmail operation. Tags correspond to characteristics of the email that you define, so that you can publish email sending events.
        public let defaultEmailTags: [MessageTag]?
        /// The ID of the multi-region endpoint (global-endpoint).
        public let endpointId: String?
        /// The address that you want bounce and complaint notifications to be sent to.
        public let feedbackForwardingEmailAddress: String?
        /// This parameter is used only for sending authorization. It is the ARN of the identity that is associated with the sending authorization policy that permits you to use the email address specified in the FeedbackForwardingEmailAddress parameter. For example, if the owner of example.com (which has ARN arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that authorizes you to use feedback@example.com, then you would specify the FeedbackForwardingEmailAddressIdentityArn to be arn:aws:ses:us-east-1:123456789012:identity/example.com, and the FeedbackForwardingEmailAddress to be feedback@example.com. For more information about sending authorization, see the Amazon SES Developer Guide.
        public let feedbackForwardingEmailAddressIdentityArn: String?
        /// The email address to use as the "From" address for the email. The address that you specify has to be verified.
        public let fromEmailAddress: String?
        /// This parameter is used only for sending authorization. It is the ARN of the identity that is associated with the sending authorization policy that permits you to use the email address specified in the FromEmailAddress parameter. For example, if the owner of example.com (which has ARN arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that authorizes you to use sender@example.com, then you would specify the FromEmailAddressIdentityArn to be arn:aws:ses:us-east-1:123456789012:identity/example.com, and the FromEmailAddress to be sender@example.com. For more information about sending authorization, see the Amazon SES Developer Guide.
        public let fromEmailAddressIdentityArn: String?
        /// The "Reply-to" email addresses for the message. When the recipient replies to the message, each Reply-to address receives the reply.
        public let replyToAddresses: [String]?

        @inlinable
        public init(bulkEmailEntries: [BulkEmailEntry], configurationSetName: String? = nil, defaultContent: BulkEmailContent, defaultEmailTags: [MessageTag]? = nil, endpointId: String? = nil, feedbackForwardingEmailAddress: String? = nil, feedbackForwardingEmailAddressIdentityArn: String? = nil, fromEmailAddress: String? = nil, fromEmailAddressIdentityArn: String? = nil, replyToAddresses: [String]? = nil) {
            self.bulkEmailEntries = bulkEmailEntries
            self.configurationSetName = configurationSetName
            self.defaultContent = defaultContent
            self.defaultEmailTags = defaultEmailTags
            self.endpointId = endpointId
            self.feedbackForwardingEmailAddress = feedbackForwardingEmailAddress
            self.feedbackForwardingEmailAddressIdentityArn = feedbackForwardingEmailAddressIdentityArn
            self.fromEmailAddress = fromEmailAddress
            self.fromEmailAddressIdentityArn = fromEmailAddressIdentityArn
            self.replyToAddresses = replyToAddresses
        }

        public func validate(name: String) throws {
            try self.bulkEmailEntries.forEach {
                try $0.validate(name: "\(name).bulkEmailEntries[]")
            }
            try self.defaultContent.validate(name: "\(name).defaultContent")
        }

        private enum CodingKeys: String, CodingKey {
            case bulkEmailEntries = "BulkEmailEntries"
            case configurationSetName = "ConfigurationSetName"
            case defaultContent = "DefaultContent"
            case defaultEmailTags = "DefaultEmailTags"
            case endpointId = "EndpointId"
            case feedbackForwardingEmailAddress = "FeedbackForwardingEmailAddress"
            case feedbackForwardingEmailAddressIdentityArn = "FeedbackForwardingEmailAddressIdentityArn"
            case fromEmailAddress = "FromEmailAddress"
            case fromEmailAddressIdentityArn = "FromEmailAddressIdentityArn"
            case replyToAddresses = "ReplyToAddresses"
        }
    }

    public struct SendBulkEmailResponse: AWSDecodableShape {
        /// One object per intended recipient. Check each response object and retry any messages with a failure status.
        public let bulkEmailEntryResults: [BulkEmailEntryResult]

        @inlinable
        public init(bulkEmailEntryResults: [BulkEmailEntryResult]) {
            self.bulkEmailEntryResults = bulkEmailEntryResults
        }

        private enum CodingKeys: String, CodingKey {
            case bulkEmailEntryResults = "BulkEmailEntryResults"
        }
    }

    public struct SendEmailRequest: AWSEncodableShape {
        /// The name of the configuration set to use when sending the email.
        public let configurationSetName: String?
        /// An object that contains the body of the message. You can send either a Simple message, Raw message, or a Templated message.
        public let content: EmailContent
        /// An object that contains the recipients of the email message.
        public let destination: Destination?
        /// A list of tags, in the form of name/value pairs, to apply to an email that you send using the SendEmail operation. Tags correspond to characteristics of the email that you define, so that you can publish email sending events.
        public let emailTags: [MessageTag]?
        /// The ID of the multi-region endpoint (global-endpoint).
        public let endpointId: String?
        /// The address that you want bounce and complaint notifications to be sent to.
        public let feedbackForwardingEmailAddress: String?
        /// This parameter is used only for sending authorization. It is the ARN of the identity that is associated with the sending authorization policy that permits you to use the email address specified in the FeedbackForwardingEmailAddress parameter. For example, if the owner of example.com (which has ARN arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that authorizes you to use feedback@example.com, then you would specify the FeedbackForwardingEmailAddressIdentityArn to be arn:aws:ses:us-east-1:123456789012:identity/example.com, and the FeedbackForwardingEmailAddress to be feedback@example.com. For more information about sending authorization, see the Amazon SES Developer Guide.
        public let feedbackForwardingEmailAddressIdentityArn: String?
        /// The email address to use as the "From" address for the email. The address that you specify has to be verified.
        public let fromEmailAddress: String?
        /// This parameter is used only for sending authorization. It is the ARN of the identity that is associated with the sending authorization policy that permits you to use the email address specified in the FromEmailAddress parameter. For example, if the owner of example.com (which has ARN arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that authorizes you to use sender@example.com, then you would specify the FromEmailAddressIdentityArn to be arn:aws:ses:us-east-1:123456789012:identity/example.com, and the FromEmailAddress to be sender@example.com. For more information about sending authorization, see the Amazon SES Developer Guide. For Raw emails, the FromEmailAddressIdentityArn value overrides the X-SES-SOURCE-ARN and X-SES-FROM-ARN headers specified in raw email message content.
        public let fromEmailAddressIdentityArn: String?
        /// An object used to specify a list or topic to which an email belongs, which will be used when a contact chooses to unsubscribe.
        public let listManagementOptions: ListManagementOptions?
        /// The "Reply-to" email addresses for the message. When the recipient replies to the message, each Reply-to address receives the reply.
        public let replyToAddresses: [String]?

        @inlinable
        public init(configurationSetName: String? = nil, content: EmailContent, destination: Destination? = nil, emailTags: [MessageTag]? = nil, endpointId: String? = nil, feedbackForwardingEmailAddress: String? = nil, feedbackForwardingEmailAddressIdentityArn: String? = nil, fromEmailAddress: String? = nil, fromEmailAddressIdentityArn: String? = nil, listManagementOptions: ListManagementOptions? = nil, replyToAddresses: [String]? = nil) {
            self.configurationSetName = configurationSetName
            self.content = content
            self.destination = destination
            self.emailTags = emailTags
            self.endpointId = endpointId
            self.feedbackForwardingEmailAddress = feedbackForwardingEmailAddress
            self.feedbackForwardingEmailAddressIdentityArn = feedbackForwardingEmailAddressIdentityArn
            self.fromEmailAddress = fromEmailAddress
            self.fromEmailAddressIdentityArn = fromEmailAddressIdentityArn
            self.listManagementOptions = listManagementOptions
            self.replyToAddresses = replyToAddresses
        }

        public func validate(name: String) throws {
            try self.content.validate(name: "\(name).content")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
            case content = "Content"
            case destination = "Destination"
            case emailTags = "EmailTags"
            case endpointId = "EndpointId"
            case feedbackForwardingEmailAddress = "FeedbackForwardingEmailAddress"
            case feedbackForwardingEmailAddressIdentityArn = "FeedbackForwardingEmailAddressIdentityArn"
            case fromEmailAddress = "FromEmailAddress"
            case fromEmailAddressIdentityArn = "FromEmailAddressIdentityArn"
            case listManagementOptions = "ListManagementOptions"
            case replyToAddresses = "ReplyToAddresses"
        }
    }

    public struct SendEmailResponse: AWSDecodableShape {
        /// A unique identifier for the message that is generated when the message is accepted.  It's possible for Amazon SES to accept a message without sending it. For example, this can happen when the message that you're trying to send has an attachment that contains a virus, or when you send a templated email that contains invalid personalization content.
        public let messageId: String?

        @inlinable
        public init(messageId: String? = nil) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SendQuota: AWSDecodableShape {
        /// The maximum number of emails that you can send in the current Amazon Web Services Region over a 24-hour period. A value of -1 signifies an unlimited quota. (This value is also referred to as your sending quota.)
        public let max24HourSend: Double?
        /// The maximum number of emails that you can send per second in the current Amazon Web Services Region. This value is also called your maximum sending rate or your maximum TPS (transactions per second) rate.
        public let maxSendRate: Double?
        /// The number of emails sent from your Amazon SES account in the current Amazon Web Services Region over the past 24 hours.
        public let sentLast24Hours: Double?

        @inlinable
        public init(max24HourSend: Double? = nil, maxSendRate: Double? = nil, sentLast24Hours: Double? = nil) {
            self.max24HourSend = max24HourSend
            self.maxSendRate = maxSendRate
            self.sentLast24Hours = sentLast24Hours
        }

        private enum CodingKeys: String, CodingKey {
            case max24HourSend = "Max24HourSend"
            case maxSendRate = "MaxSendRate"
            case sentLast24Hours = "SentLast24Hours"
        }
    }

    public struct SendingOptions: AWSEncodableShape & AWSDecodableShape {
        /// If true, email sending is enabled for the configuration set. If false, email sending is disabled for the configuration set.
        public let sendingEnabled: Bool?

        @inlinable
        public init(sendingEnabled: Bool? = nil) {
            self.sendingEnabled = sendingEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case sendingEnabled = "SendingEnabled"
        }
    }

    public struct SnsDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic to publish email events to. For more information about Amazon SNS topics, see the Amazon SNS Developer Guide.
        public let topicArn: String

        @inlinable
        public init(topicArn: String) {
            self.topicArn = topicArn
        }

        private enum CodingKeys: String, CodingKey {
            case topicArn = "TopicArn"
        }
    }

    public struct SuppressedDestination: AWSDecodableShape {
        /// An optional value that can contain additional information about the reasons that the address was added to the suppression list for your account.
        public let attributes: SuppressedDestinationAttributes?
        /// The email address that is on the suppression list for your account.
        public let emailAddress: String
        /// The date and time when the suppressed destination was last updated, shown in Unix time format.
        public let lastUpdateTime: Date
        /// The reason that the address was added to the suppression list for your account.
        public let reason: SuppressionListReason

        @inlinable
        public init(attributes: SuppressedDestinationAttributes? = nil, emailAddress: String, lastUpdateTime: Date, reason: SuppressionListReason) {
            self.attributes = attributes
            self.emailAddress = emailAddress
            self.lastUpdateTime = lastUpdateTime
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case emailAddress = "EmailAddress"
            case lastUpdateTime = "LastUpdateTime"
            case reason = "Reason"
        }
    }

    public struct SuppressedDestinationAttributes: AWSDecodableShape {
        /// A unique identifier that's generated when an email address is added to the suppression list for your account.
        public let feedbackId: String?
        /// The unique identifier of the email message that caused the email address to be added to the suppression list for your account.
        public let messageId: String?

        @inlinable
        public init(feedbackId: String? = nil, messageId: String? = nil) {
            self.feedbackId = feedbackId
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case feedbackId = "FeedbackId"
            case messageId = "MessageId"
        }
    }

    public struct SuppressedDestinationSummary: AWSDecodableShape {
        /// The email address that's on the suppression list for your account.
        public let emailAddress: String
        /// The date and time when the suppressed destination was last updated, shown in Unix time format.
        public let lastUpdateTime: Date
        /// The reason that the address was added to the suppression list for your account.
        public let reason: SuppressionListReason

        @inlinable
        public init(emailAddress: String, lastUpdateTime: Date, reason: SuppressionListReason) {
            self.emailAddress = emailAddress
            self.lastUpdateTime = lastUpdateTime
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case emailAddress = "EmailAddress"
            case lastUpdateTime = "LastUpdateTime"
            case reason = "Reason"
        }
    }

    public struct SuppressionAttributes: AWSDecodableShape {
        /// A list that contains the reasons that email addresses will be automatically added to the suppression list for your account. This list can contain any or all of the following:    COMPLAINT – Amazon SES adds an email address to the suppression list for your account when a message sent to that address results in a complaint.    BOUNCE – Amazon SES adds an email address to the suppression list for your account when a message sent to that address results in a hard bounce.
        public let suppressedReasons: [SuppressionListReason]?

        @inlinable
        public init(suppressedReasons: [SuppressionListReason]? = nil) {
            self.suppressedReasons = suppressedReasons
        }

        private enum CodingKeys: String, CodingKey {
            case suppressedReasons = "SuppressedReasons"
        }
    }

    public struct SuppressionListDestination: AWSEncodableShape & AWSDecodableShape {
        /// The type of action to perform on the address. The following are possible values:   PUT: add the addresses to the suppression list. If the record already exists, it will override it with the new value.   DELETE: remove the addresses from the suppression list.
        public let suppressionListImportAction: SuppressionListImportAction

        @inlinable
        public init(suppressionListImportAction: SuppressionListImportAction) {
            self.suppressionListImportAction = suppressionListImportAction
        }

        private enum CodingKeys: String, CodingKey {
            case suppressionListImportAction = "SuppressionListImportAction"
        }
    }

    public struct SuppressionOptions: AWSEncodableShape & AWSDecodableShape {
        /// A list that contains the reasons that email addresses are automatically added to the suppression list for your account. This list can contain any or all of the following:    COMPLAINT – Amazon SES adds an email address to the suppression list for your account when a message sent to that address results in a complaint.    BOUNCE – Amazon SES adds an email address to the suppression list for your account when a message sent to that address results in a hard bounce.
        public let suppressedReasons: [SuppressionListReason]?

        @inlinable
        public init(suppressedReasons: [SuppressionListReason]? = nil) {
            self.suppressedReasons = suppressedReasons
        }

        private enum CodingKeys: String, CodingKey {
            case suppressedReasons = "SuppressedReasons"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that defines a tag. The maximum length of a tag key is 128 characters. The minimum length is 1 character.
        public let key: String
        /// The optional part of a key-value pair that defines a tag. The maximum length of a tag value is 256 characters. The minimum length is 0 characters. If you don't want a resource to have a specific tag value, don't specify a value for this parameter. If you don't specify a value, Amazon SES sets the value to an empty string.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to add one or more tags to.
        public let resourceArn: String
        /// A list of the tags that you want to add to the resource. A tag consists of a required tag key (Key) and an associated tag value (Value). The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Template: AWSEncodableShape {
        /// The list of message headers that will be added to the email message.
        public let headers: [MessageHeader]?
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String?
        /// The content of the template.  Amazon SES supports only simple substitions when you send email using the   SendEmail or SendBulkEmail operations and  you provide the full template content in the request.
        public let templateContent: EmailTemplateContent?
        /// An object that defines the values to use for message variables in the template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the value to use for that variable.
        public let templateData: String?
        /// The name of the template. You will refer to this name when you send email using the SendTemplatedEmail or SendBulkTemplatedEmail operations.
        public let templateName: String?

        @inlinable
        public init(headers: [MessageHeader]? = nil, templateArn: String? = nil, templateContent: EmailTemplateContent? = nil, templateData: String? = nil, templateName: String? = nil) {
            self.headers = headers
            self.templateArn = templateArn
            self.templateContent = templateContent
            self.templateData = templateData
            self.templateName = templateName
        }

        public func validate(name: String) throws {
            try self.headers?.forEach {
                try $0.validate(name: "\(name).headers[]")
            }
            try self.validate(self.headers, name: "headers", parent: name, max: 15)
            try self.validate(self.templateData, name: "templateData", parent: name, max: 262144)
            try self.validate(self.templateName, name: "templateName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case headers = "Headers"
            case templateArn = "TemplateArn"
            case templateContent = "TemplateContent"
            case templateData = "TemplateData"
            case templateName = "TemplateName"
        }
    }

    public struct Topic: AWSEncodableShape & AWSDecodableShape {
        /// The default subscription status to be applied to a contact if the contact has not noted their preference for subscribing to a topic.
        public let defaultSubscriptionStatus: SubscriptionStatus
        /// A description of what the topic is about, which the contact will see.
        public let description: String?
        /// The name of the topic the contact will see.
        public let displayName: String
        /// The name of the topic.
        public let topicName: String

        @inlinable
        public init(defaultSubscriptionStatus: SubscriptionStatus, description: String? = nil, displayName: String, topicName: String) {
            self.defaultSubscriptionStatus = defaultSubscriptionStatus
            self.description = description
            self.displayName = displayName
            self.topicName = topicName
        }

        private enum CodingKeys: String, CodingKey {
            case defaultSubscriptionStatus = "DefaultSubscriptionStatus"
            case description = "Description"
            case displayName = "DisplayName"
            case topicName = "TopicName"
        }
    }

    public struct TopicFilter: AWSEncodableShape {
        /// The name of a topic on which you wish to apply the filter.
        public let topicName: String?
        /// Notes that the default subscription status should be applied to a contact because the contact has not noted their preference for subscribing to a topic.
        public let useDefaultIfPreferenceUnavailable: Bool?

        @inlinable
        public init(topicName: String? = nil, useDefaultIfPreferenceUnavailable: Bool? = nil) {
            self.topicName = topicName
            self.useDefaultIfPreferenceUnavailable = useDefaultIfPreferenceUnavailable
        }

        private enum CodingKeys: String, CodingKey {
            case topicName = "TopicName"
            case useDefaultIfPreferenceUnavailable = "UseDefaultIfPreferenceUnavailable"
        }
    }

    public struct TopicPreference: AWSEncodableShape & AWSDecodableShape {
        /// The contact's subscription status to a topic which is either OPT_IN or OPT_OUT.
        public let subscriptionStatus: SubscriptionStatus
        /// The name of the topic.
        public let topicName: String

        @inlinable
        public init(subscriptionStatus: SubscriptionStatus, topicName: String) {
            self.subscriptionStatus = subscriptionStatus
            self.topicName = topicName
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionStatus = "SubscriptionStatus"
            case topicName = "TopicName"
        }
    }

    public struct TrackingOptions: AWSEncodableShape & AWSDecodableShape {
        /// The domain to use for tracking open and click events.
        public let customRedirectDomain: String
        /// The https policy to use for tracking open and click events.
        public let httpsPolicy: HttpsPolicy?

        @inlinable
        public init(customRedirectDomain: String, httpsPolicy: HttpsPolicy? = nil) {
            self.customRedirectDomain = customRedirectDomain
            self.httpsPolicy = httpsPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case customRedirectDomain = "CustomRedirectDomain"
            case httpsPolicy = "HttpsPolicy"
        }
    }
}

// MARK: - Errors

/// Error enum for SESv2
public struct SESv2ErrorType: AWSErrorType {
    enum Code: String {
        case accountSuspendedException = "AccountSuspendedException"
        case alreadyExistsException = "AlreadyExistsException"
        case badRequestException = "BadRequestException"
        case concurrentModificationException = "ConcurrentModificationException"
        case conflictException = "ConflictException"
        case internalServiceErrorException = "InternalServiceErrorException"
        case invalidNextTokenException = "InvalidNextTokenException"
        case limitExceededException = "LimitExceededException"
        case mailFromDomainNotVerifiedException = "MailFromDomainNotVerifiedException"
        case messageRejected = "MessageRejected"
        case notFoundException = "NotFoundException"
        case sendingPausedException = "SendingPausedException"
        case tooManyRequestsException = "TooManyRequestsException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize SESv2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The message can't be sent because the account's ability to send email has been permanently restricted.
    public static var accountSuspendedException: Self { .init(.accountSuspendedException) }
    /// The resource specified in your request already exists.
    public static var alreadyExistsException: Self { .init(.alreadyExistsException) }
    /// The input you provided is invalid.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The resource is being modified by another operation or thread.
    public static var concurrentModificationException: Self { .init(.concurrentModificationException) }
    /// If there is already an ongoing account details update under review.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request couldn't be processed because an error occurred with the Amazon SES API v2.
    public static var internalServiceErrorException: Self { .init(.internalServiceErrorException) }
    /// The specified request includes an invalid or expired token.
    public static var invalidNextTokenException: Self { .init(.invalidNextTokenException) }
    /// There are too many instances of the specified resource type.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The message can't be sent because the sending domain isn't verified.
    public static var mailFromDomainNotVerifiedException: Self { .init(.mailFromDomainNotVerifiedException) }
    /// The message can't be sent because it contains invalid content.
    public static var messageRejected: Self { .init(.messageRejected) }
    /// The resource you attempted to access doesn't exist.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// The message can't be sent because the account's ability to send email is currently paused.
    public static var sendingPausedException: Self { .init(.sendingPausedException) }
    /// Too many requests have been made to the operation.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
}

extension SESv2ErrorType: Equatable {
    public static func == (lhs: SESv2ErrorType, rhs: SESv2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SESv2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
